
 /**
  * This template file was generated by dynaTrace client.
  * The dynaTrace community portal can be found here: http://community.compuwareapm.com/
  * For information how to publish a plugin please visit http://community.compuwareapm.com/plugins/contribute/
  **/ 

package com.compuware.plugin;

import com.dynatrace.diagnostics.pdk.*;
import java.util.logging.Logger;
import java.util.logging.Level;
import com.jcraft.jsch.*;
import java.util.Collection;
import java.io.*;
import java.net.ConnectException;


public class RunQueueMonitor implements Monitor {

    private static final String CONFIG_USERNAME = "username";
	private static final String CONFIG_PASSWORD = "password";
	private static final String CONFIG_HOST     = "host";
	private static final String COMMAND         = "vmstat";
	private static final int    START_INDEX     = 163;
	private static final int    STOP_INDEX      = 165;
	private static final Logger log = Logger.getLogger(RunQueueMonitor.class.getName());
    
	private String username;
	private String password;
	private String hostname;
    private String response; // The response I get back from the execution of the command.  This is what will be parsed to extract the runqueue size.
    private Integer runQueueSize = 0;

	
	@Override
	public Status setup(MonitorEnvironment env) throws Exception {
        getArgs(env);
        return new Status(Status.StatusCode.Success);
	}

	/**
	 * Executes the Monitor Plugin to retrieve subscribed measures and store
	 * measurements.
	*/ 
	@Override
	public Status execute(MonitorEnvironment env) throws Exception {
		Status status = new Status();
		try {
			response = executeCommand();
			if (response != null) {
		   		runQueueSize = parseResponse(response);
		   		populateMeasure(runQueueSize, env);
		    	status.setStatusCode(Status.StatusCode.Success);
		    	log.log(Level.WARNING, "Got here" + response + ":::" + runQueueSize + ":");
			} else {
		   		status.setStatusCode(Status.StatusCode.ErrorTargetService);
		   		status.setMessage("Response string was null. Aborting.");
        	}
        } catch (Exception ex) {
       		  log.log(Level.WARNING, "Exception: ", ex);
       		  status.setShortMessage("Exception: " + ex.getMessage());
       		  status.setStatusCode(Status.StatusCode.ErrorTargetService);
       		  //status.setException(ex);  //Only really needed for debugging.
       	} 
        return status;
	}
	

	/**
	 * Shuts the Plugin down and frees resources. This method is called in the
	 * following cases:
	 * <ul>
	 * <li>the <tt>setup</tt> method failed</li>
	 * <li>the Plugin configuration has changed</li>
	 * <li>the execution duration of the Plugin exceeded the schedule timeout</li>
	 * <li>the schedule associated with this Plugin was removed</li>
	 * </ul>
	 * @see Monitor#setup(MonitorEnvironment)
	 */	
	 @Override
	public void teardown(MonitorEnvironment env) throws Exception {
		// TODO
	}
    
    private void getArgs(MonitorEnvironment env) {
        username = env.getConfigString(CONFIG_USERNAME);
        password = env.getConfigPassword(CONFIG_PASSWORD);
        hostname = env.getConfigString(CONFIG_HOST);
    }
    
    private String executeCommand() throws Exception {
    	Status status = new Status();
    	String output = new String();
 
		JSch jsch=new JSch();
        Session session=jsch.getSession(username, hostname, 22);
        session.setPassword(password);
        session.setConfig("StrictHostKeyChecking", "no");
        session.connect(30000); // Connect using timeout
        Channel channel=session.openChannel("exec");
        ((ChannelExec)channel).setCommand(COMMAND);
        channel.setInputStream(null);
  		((ChannelExec)channel).setErrStream(System.err);
        InputStream in=channel.getInputStream();
        channel.connect();
 
  		byte[] tmp=new byte[2048];
		while(true){
			while(in.available()>0){
				int i=in.read(tmp, 0, 2048);
				if(i<0)break;
				output = new String(tmp,0,i);
			}
			if(channel.isClosed()){
				break;
			}
			try{Thread.sleep(1000);}catch(Exception ee){};
		}
		channel.disconnect();
		session.disconnect(); 
    	return output;
    }
    
    private Integer parseResponse(String response) {
        String temp = response.substring(START_INDEX,STOP_INDEX);
        return new Integer(temp.trim());
    }
    
    private void populateMeasure(Integer queueSize, MonitorEnvironment env) {
    	Collection<MonitorMeasure> measures;
    	measures = env.getMonitorMeasures("RunQueueMonitorMetric", "QueueSize");
    	if (measures != null) {
	       for (MonitorMeasure measure : measures) {
	    		measure.setValue(queueSize);
	       }
    	}
    }
    
}
